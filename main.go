package main

import (
	"fmt"
	"os"
	"os/exec"
	"os/signal"
	"syscall"
)

func main() {
	fmt.Println("Запускаем приложение-обертку для Xray...")

	// Указываем путь к исполняемому файлу Xray и файлу конфигурации.
	// Они находятся в разных папках, как мы и настраивали.
	xrayPath := "./xray_core/xray.exe"
	configPath := "./config.json"

	// Создаем команду для запуска Xray.
	// Первый аргумент - это сама программа,
	// второй - флаг "-c", который говорит Xray использовать файл конфигурации,
	// третий - путь к этому файлу.
	cmd := exec.Command(xrayPath, "-c", configPath)

	// Перенаправляем стандартный вывод (логи) и ошибки из процесса Xray
	// в консоль нашего Go-приложения. Так мы будем видеть все, что выводит Xray.
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	// Запускаем команду. Start() запускает процесс в фоне и не блокирует
	// выполнение нашей программы.
	err := cmd.Start()
	if err != nil {
		fmt.Println("Ошибка при запуске Xray:", err)
		return // Если не удалось запустить, выходим из программы.
	}

	// Выводим информацию о запущенном процессе.
	fmt.Printf("Xray запущен успешно с PID: %d\n", cmd.Process.Pid)
	fmt.Println("Прокси работает. Нажмите Ctrl+C для остановки.")

	// --- Блок для graceful shutdown (корректной остановки) ---
	// Создаем канал, который будет ждать системных сигналов.
	quit := make(chan os.Signal, 1)
	// Мы будем "ловить" сигнал прерывания (Ctrl+C)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM)

	// Эта строка заблокирует выполнение программы до тех пор,
	// пока в канал `quit` не придет сигнал.
	<-quit

	// Как только сигнал получен (нажали Ctrl+C), выполняем код ниже.
	fmt.Println("\nПолучен сигнал остановки. Завершаем процесс Xray...")

	// Отправляем сигнал завершения процессу Xray.
	err = cmd.Process.Kill()
	if err != nil {
		fmt.Println("Не удалось остановить процесс Xray:", err)
	} else {
		fmt.Println("Процесс Xray успешно остановлен.")
	}
}